"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyTree = void 0;
const branch_1 = require("./branch");
const utils_1 = require("./utils");
class ProxyTree {
    constructor(target) {
        var _a;
        this.rootBranch = this.createBranch(target);
        this.proxy = (((_a = this.rootBranch) === null || _a === void 0 ? void 0 : _a.proxy) || null);
    }
    createBranch(target) {
        if (!utils_1.isObject(target)) {
            console.error("ProxyTree: The ProxyTree accepts only values from the type 'object' and 'array'! " +
                `The passed type was '${typeof target}'! ` +
                'Learn more here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy');
            return null;
        }
        return new branch_1.Branch(this, target);
    }
    transformTreeToBranchObject() {
        let rootBranchUses = 0;
        this.rootBranch.childBranches.forEach((childBranch) => (rootBranchUses += childBranch.timesAccessed));
        const rootBranch = {
            key: 'root',
            timesAccessed: rootBranchUses,
            branches: [],
        };
        const walk = (branch, currentBranchObject) => {
            const childBranches = branch.childBranches;
            if (childBranches.size > 0) {
                childBranches.forEach((branchRoute) => {
                    const newBranchObject = {
                        key: branchRoute.key,
                        timesAccessed: branchRoute.timesAccessed,
                        branches: [],
                    };
                    currentBranchObject.branches.push(newBranchObject);
                    if (branchRoute.branch) {
                        walk(branchRoute.branch, newBranchObject);
                    }
                });
            }
        };
        walk(this.rootBranch, rootBranch);
        return rootBranch;
    }
    getUsedRoutes() {
        const usedRoutes = [];
        const inRoutes = (path) => {
            for (const route of usedRoutes) {
                if (JSON.stringify(route) === JSON.stringify(path))
                    return true;
            }
            return false;
        };
        const rootBranchObject = this.transformTreeToBranchObject();
        const walk = (branchObject, path) => {
            let branchChildRoutesTimesUsed = 0;
            branchObject.branches.forEach((childBranch) => (branchChildRoutesTimesUsed += childBranch.timesAccessed));
            if (branchObject.branches.length > 0 &&
                branchObject.timesAccessed > 0 &&
                branchChildRoutesTimesUsed > 0) {
                branchObject.branches.forEach((branchChildObject) => {
                    if (branchChildObject.timesAccessed > 0) {
                        walk(branchChildObject, path ? [...path, branchChildObject.key] : [branchChildObject.key]);
                    }
                    branchObject.timesAccessed -= 1;
                });
            }
            else {
                if (path && !inRoutes(path))
                    usedRoutes.push(path);
                if (branchObject.timesAccessed > 0)
                    branchObject.timesAccessed -= 1;
            }
        };
        while (rootBranchObject.timesAccessed > 0) {
            walk(rootBranchObject);
        }
        return usedRoutes;
    }
}
exports.ProxyTree = ProxyTree;
