"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Collection = void 0;
const internal_1 = require("../internal");
class Collection {
    constructor(agileInstance, config = {}) {
        this.size = 0;
        this.data = {};
        this.isPersisted = false;
        this.groups = {};
        this.selectors = {};
        this.isInstantiated = false;
        this.agileInstance = () => agileInstance;
        this.config = {
            defaultGroupKey: 'default',
            primaryKey: 'id',
        };
        let _config = typeof config === 'function' ? config(this) : config;
        _config = internal_1.defineConfig(_config, {
            primaryKey: 'id',
            groups: {},
            selectors: {},
            defaultGroupKey: 'default',
        });
        this._key = _config.key;
        this.config = {
            defaultGroupKey: _config.defaultGroupKey,
            primaryKey: _config.primaryKey,
        };
        this.initialConfig = _config;
        this.initGroups(_config.groups);
        this.initSelectors(_config.selectors);
        if (_config.initialData)
            this.collect(_config.initialData);
        this.isInstantiated = true;
    }
    set key(value) {
        this.setKey(value);
    }
    get key() {
        return this._key;
    }
    setKey(value) {
        var _a, _b;
        const oldKey = this._key;
        this._key = value;
        if (value && ((_a = this.persistent) === null || _a === void 0 ? void 0 : _a._key) === oldKey)
            (_b = this.persistent) === null || _b === void 0 ? void 0 : _b.setKey(value);
        return this;
    }
    Group(initialItems, config = {}) {
        if (this.isInstantiated) {
            const key = (config === null || config === void 0 ? void 0 : config.key) || internal_1.generateId();
            internal_1.Agile.logger.warn("After the instantiation we recommend using 'MY_COLLECTION.createGroup' instead of 'MY_COLLECTION.Group'");
            if (!(config === null || config === void 0 ? void 0 : config.key))
                internal_1.Agile.logger.warn(`Failed to find key for creation of Group. Group with random key '${key}' got created!`);
            return this.createGroup(key, initialItems);
        }
        return new internal_1.Group(this, initialItems, config);
    }
    Selector(initialKey, config = {}) {
        if (this.isInstantiated) {
            const key = (config === null || config === void 0 ? void 0 : config.key) || internal_1.generateId();
            internal_1.Agile.logger.warn("After the instantiation we recommend using 'MY_COLLECTION.createSelector' instead of 'MY_COLLECTION.Selector'");
            if (!(config === null || config === void 0 ? void 0 : config.key))
                internal_1.Agile.logger.warn(`Failed to find key for creation of Selector. Selector with random key '${key}' got created!`);
            return this.createSelector(key, initialKey);
        }
        return new internal_1.Selector(this, initialKey, config);
    }
    initGroups(groups) {
        if (!groups)
            return;
        let groupsObject = {};
        if (Array.isArray(groups)) {
            groups.forEach((groupKey) => {
                groupsObject[groupKey] = new internal_1.Group(this, [], {
                    key: groupKey,
                });
            });
        }
        else
            groupsObject = groups;
        groupsObject[this.config.defaultGroupKey] = new internal_1.Group(this, [], {
            key: this.config.defaultGroupKey,
        });
        for (const key in groupsObject)
            if (!groupsObject[key]._key)
                groupsObject[key].setKey(key);
        this.groups = groupsObject;
    }
    initSelectors(selectors) {
        if (!selectors)
            return;
        let selectorsObject = {};
        if (Array.isArray(selectors)) {
            selectors.forEach((selectorKey) => {
                selectorsObject[selectorKey] = new internal_1.Selector(this, selectorKey, {
                    key: selectorKey,
                });
            });
        }
        else
            selectorsObject = selectors;
        for (const key in selectorsObject)
            if (!selectorsObject[key]._key)
                selectorsObject[key].setKey(key);
        this.selectors = selectorsObject;
    }
    collect(data, groupKeys, config = {}) {
        const _data = internal_1.normalizeArray(data);
        const _groupKeys = internal_1.normalizeArray(groupKeys);
        const defaultGroupKey = this.config.defaultGroupKey;
        const primaryKey = this.config.primaryKey;
        config = internal_1.defineConfig(config, {
            method: 'push',
            background: false,
            patch: false,
            select: false,
        });
        if (!_groupKeys.includes(defaultGroupKey))
            _groupKeys.push(defaultGroupKey);
        _groupKeys.forEach((key) => !this.groups[key] && this.createGroup(key));
        _data.forEach((data, index) => {
            const itemKey = data[primaryKey];
            const success = this.setData(data, {
                patch: config.patch,
                background: config.background,
            });
            if (!success)
                return this;
            _groupKeys.forEach((groupKey) => {
                var _a;
                (_a = this.getGroup(groupKey)) === null || _a === void 0 ? void 0 : _a.add(itemKey, {
                    method: config.method,
                    background: config.background,
                });
            });
            if (config.select)
                this.createSelector(itemKey, itemKey);
            if (config.forEachItem)
                config.forEachItem(data, itemKey, index);
        });
        return this;
    }
    update(itemKey, changes, config = {}) {
        const item = this.getItem(itemKey, { notExisting: true });
        const primaryKey = this.config.primaryKey;
        config = internal_1.defineConfig(config, {
            patch: true,
            background: false,
        });
        if (!item) {
            internal_1.Agile.logger.error(`Item with key/name '${itemKey}' doesn't exist in Collection '${this._key}'!`);
            return undefined;
        }
        if (!internal_1.isValidObject(changes)) {
            internal_1.Agile.logger.error(`You have to pass an valid Changes Object to update '${itemKey}' in '${this._key}'!`);
            return undefined;
        }
        const oldItemKey = item._value[primaryKey];
        const newItemKey = changes[primaryKey] || oldItemKey;
        const updateItemKey = oldItemKey !== newItemKey;
        if (updateItemKey)
            this.updateItemKey(oldItemKey, newItemKey, {
                background: config.background,
            });
        if (config.patch) {
            if (changes[primaryKey])
                delete changes[primaryKey];
            let patchConfig = typeof config.patch === 'object' ? config.patch : {};
            patchConfig = internal_1.defineConfig(patchConfig, {
                addNewProperties: true,
            });
            item.patch(changes, {
                background: config.background,
                addNewProperties: patchConfig.addNewProperties,
            });
        }
        if (!config.patch) {
            if (changes[this.config.primaryKey] !== itemKey) {
                changes[this.config.primaryKey] = itemKey;
                internal_1.Agile.logger.warn(`By overwriting the whole Item don't forget passing the correct primaryKey!`, changes);
            }
            item.set(changes, {
                background: config.background,
            });
        }
        return item;
    }
    createGroup(groupKey, initialItems = []) {
        let group = this.getGroup(groupKey, { notExisting: true });
        if (!this.isInstantiated) {
            internal_1.Agile.logger.warn("We recommend to use 'MY_COLLECTION.Group' instead of 'MY_COLLECTION.createGroup' in the Collection config!");
        }
        if (group) {
            if (!group.isPlaceholder) {
                internal_1.Agile.logger.warn(`Group with the name '${groupKey}' already exists!`);
                return group;
            }
            group.set(initialItems, { overwrite: true });
            return group;
        }
        group = new internal_1.Group(this, initialItems, { key: groupKey });
        this.groups[groupKey] = group;
        return group;
    }
    hasGroup(groupKey, config = {}) {
        return !!this.getGroup(groupKey, config);
    }
    getGroup(groupKey, config = {}) {
        config = internal_1.defineConfig(config, {
            notExisting: false,
        });
        const group = groupKey ? this.groups[groupKey] : undefined;
        if (!group || (!config.notExisting && group.isPlaceholder))
            return undefined;
        internal_1.ComputedTracker.tracked(group.observer);
        return group;
    }
    getGroupWithReference(groupKey) {
        let group = this.getGroup(groupKey, { notExisting: true });
        if (!group) {
            group = new internal_1.Group(this, [], {
                key: groupKey,
                isPlaceholder: true,
            });
            this.groups[groupKey] = group;
        }
        internal_1.ComputedTracker.tracked(group.observer);
        return group;
    }
    removeGroup(groupKey) {
        if (!this.groups[groupKey]) {
            internal_1.Agile.logger.warn(`Group with the key/name '${groupKey}' doesn't exist!`);
            return this;
        }
        delete this.groups[groupKey];
        return this;
    }
    createSelector(selectorKey, itemKey) {
        let selector = this.getSelector(selectorKey, { notExisting: true });
        if (!this.isInstantiated) {
            internal_1.Agile.logger.warn("We recommend to use 'MY_COLLECTION.Selector' instead of 'MY_COLLECTION.createSelector' in the Collection config!");
        }
        if (selector) {
            if (!selector.isPlaceholder) {
                internal_1.Agile.logger.warn(`Selector with the name '${selectorKey}' already exists!`);
                return selector;
            }
            selector.select(itemKey, { overwrite: true });
            return selector;
        }
        selector = new internal_1.Selector(this, itemKey, {
            key: selectorKey,
        });
        this.selectors[selectorKey] = selector;
        return selector;
    }
    select(itemKey) {
        return this.createSelector(itemKey, itemKey);
    }
    hasSelector(selectorKey, config = {}) {
        return !!this.getSelector(selectorKey, config);
    }
    getSelector(selectorKey, config = {}) {
        config = internal_1.defineConfig(config, {
            notExisting: false,
        });
        const selector = selectorKey ? this.selectors[selectorKey] : undefined;
        if (!selector || (!config.notExisting && selector.isPlaceholder))
            return undefined;
        internal_1.ComputedTracker.tracked(selector.observer);
        return selector;
    }
    getSelectorWithReference(selectorKey) {
        let selector = this.getSelector(selectorKey, { notExisting: true });
        if (!selector) {
            selector = new internal_1.Selector(this, 'unknown', {
                key: selectorKey,
                isPlaceholder: true,
            });
            this.selectors[selectorKey] = selector;
        }
        internal_1.ComputedTracker.tracked(selector.observer);
        return selector;
    }
    removeSelector(selectorKey) {
        var _a;
        if (!this.selectors[selectorKey]) {
            internal_1.Agile.logger.warn(`Selector with the key/name '${selectorKey}' doesn't exist!`);
            return this;
        }
        (_a = this.selectors[selectorKey]) === null || _a === void 0 ? void 0 : _a.unselect();
        delete this.selectors[selectorKey];
        return this;
    }
    hasItem(itemKey, config = {}) {
        return !!this.getItem(itemKey, config);
    }
    getItem(itemKey, config = {}) {
        config = internal_1.defineConfig(config, {
            notExisting: false,
        });
        const item = itemKey ? this.data[itemKey] : undefined;
        if (!item || (!config.notExisting && !item.exists))
            return undefined;
        internal_1.ComputedTracker.tracked(item.observer);
        return item;
    }
    getItemWithReference(itemKey) {
        let item = this.getItem(itemKey, { notExisting: true });
        if (!item) {
            item = new internal_1.Item(this, {
                [this.config.primaryKey]: itemKey,
                dummy: 'item',
            }, {
                isPlaceholder: true,
            });
            this.data[itemKey] = item;
        }
        internal_1.ComputedTracker.tracked(item.observer);
        return item;
    }
    getItemValue(itemKey, config = {}) {
        const item = this.getItem(itemKey, config);
        if (!item)
            return undefined;
        return item.value;
    }
    getAllItems(config = {}) {
        config = internal_1.defineConfig(config, {
            notExisting: false,
        });
        const items = [];
        for (const key in this.data) {
            const item = this.data[key];
            if ((!config.notExisting && item.exists) || config.notExisting) {
                items.push(item);
            }
        }
        return items;
    }
    getAllItemValues(config = {}) {
        const items = this.getAllItems(config);
        return items.map((item) => item.value);
    }
    persist(keyOrConfig = {}, config = {}) {
        let _config;
        let key;
        if (internal_1.isValidObject(keyOrConfig)) {
            _config = keyOrConfig;
            key = this._key;
        }
        else {
            _config = config || {};
            key = keyOrConfig;
        }
        _config = internal_1.defineConfig(_config, {
            loadValue: true,
            storageKeys: [],
            defaultStorageKey: null,
        });
        if (this.persistent)
            internal_1.Agile.logger.warn(`By persisting the Collection '${this._key}' twice you overwrite the old Persistent Instance!`);
        this.persistent = new internal_1.CollectionPersistent(this, {
            instantiate: _config.loadValue,
            storageKeys: _config.storageKeys,
            key: key,
            defaultStorageKey: _config.defaultStorageKey,
        });
        return this;
    }
    onLoad(callback) {
        if (this.persistent) {
            this.persistent.onLoad = callback;
            if (this.isPersisted)
                callback(true);
        }
        else {
            internal_1.Agile.logger.error(`Please make sure you persist the Collection '${this._key}' before using the 'onLoad' function!`);
        }
        return this;
    }
    getGroupCount() {
        let size = 0;
        for (const group in this.groups)
            size++;
        return size;
    }
    getSelectorCount() {
        let size = 0;
        for (const selector in this.selectors)
            size++;
        return size;
    }
    reset() {
        var _a, _b;
        this.data = {};
        this.size = 0;
        for (const key in this.groups)
            (_a = this.getGroup(key)) === null || _a === void 0 ? void 0 : _a.reset();
        for (const key in this.selectors)
            (_b = this.getSelector(key)) === null || _b === void 0 ? void 0 : _b.reset();
        return this;
    }
    put(itemKeys, groupKeys, config = {}) {
        const _itemKeys = internal_1.normalizeArray(itemKeys);
        const _groupKeys = internal_1.normalizeArray(groupKeys);
        _groupKeys.forEach((groupKey) => {
            var _a;
            (_a = this.getGroup(groupKey)) === null || _a === void 0 ? void 0 : _a.add(_itemKeys, config);
        });
        return this;
    }
    updateItemKey(oldItemKey, newItemKey, config = {}) {
        var _a;
        const item = this.getItem(oldItemKey, { notExisting: true });
        config = internal_1.defineConfig(config, {
            background: false,
        });
        if (!item || oldItemKey === newItemKey)
            return false;
        if (this.hasItem(newItemKey)) {
            internal_1.Agile.logger.warn(`Couldn't update ItemKey from '${oldItemKey}' to '${newItemKey}' because an Item with the key/name '${newItemKey}' already exists!`);
            return false;
        }
        delete this.data[oldItemKey];
        this.data[newItemKey] = item;
        item.setKey(newItemKey, {
            background: config.background,
        });
        (_a = item.persistent) === null || _a === void 0 ? void 0 : _a.setKey(internal_1.CollectionPersistent.getItemStorageKey(newItemKey, this._key));
        for (const groupKey in this.groups) {
            const group = this.getGroup(groupKey, { notExisting: true });
            if (!group || !group.has(oldItemKey))
                continue;
            group.replace(oldItemKey, newItemKey, { background: config.background });
        }
        for (const selectorKey in this.selectors) {
            const selector = this.getSelector(selectorKey, { notExisting: true });
            if (!selector)
                continue;
            if (selector.hasSelected(newItemKey)) {
                selector.select(newItemKey, {
                    force: true,
                    background: config.background,
                });
            }
            if (selector.hasSelected(oldItemKey))
                selector.select(newItemKey, {
                    background: config === null || config === void 0 ? void 0 : config.background,
                });
        }
        return true;
    }
    getGroupKeysThatHaveItemKey(itemKey) {
        const groupKeys = [];
        for (const groupKey in this.groups) {
            const group = this.getGroup(groupKey, { notExisting: true });
            if (group === null || group === void 0 ? void 0 : group.has(itemKey))
                groupKeys.push(groupKey);
        }
        return groupKeys;
    }
    remove(itemKeys) {
        return {
            fromGroups: (groups) => this.removeFromGroups(itemKeys, groups),
            everywhere: () => this.removeItems(itemKeys),
        };
    }
    removeFromGroups(itemKeys, groupKeys) {
        const _itemKeys = internal_1.normalizeArray(itemKeys);
        const _groupKeys = internal_1.normalizeArray(groupKeys);
        _itemKeys.forEach((itemKey) => {
            let removedFromGroupsCount = 0;
            _groupKeys.forEach((groupKey) => {
                const group = this.getGroup(groupKey, { notExisting: true });
                if (!group || !group.has(itemKey))
                    return;
                group.remove(itemKey);
                removedFromGroupsCount++;
            });
            if (removedFromGroupsCount >=
                this.getGroupKeysThatHaveItemKey(itemKey).length)
                this.removeItems(itemKey);
        });
        return this;
    }
    removeItems(itemKeys) {
        const _itemKeys = internal_1.normalizeArray(itemKeys);
        _itemKeys.forEach((itemKey) => {
            var _a;
            const item = this.getItem(itemKey, { notExisting: true });
            if (!item)
                return;
            for (const groupKey in this.groups) {
                const group = this.getGroup(groupKey, { notExisting: true });
                if (group === null || group === void 0 ? void 0 : group.has(itemKey))
                    group === null || group === void 0 ? void 0 : group.remove(itemKey);
            }
            (_a = item.persistent) === null || _a === void 0 ? void 0 : _a.removePersistedValue();
            delete this.data[itemKey];
            for (const selectorKey in this.selectors) {
                const selector = this.getSelector(selectorKey, { notExisting: true });
                if (selector === null || selector === void 0 ? void 0 : selector.hasSelected(itemKey))
                    selector === null || selector === void 0 ? void 0 : selector.select(itemKey, { force: true });
            }
            this.size--;
        });
        return this;
    }
    setData(data, config = {}) {
        const _data = internal_1.copy(data);
        const primaryKey = this.config.primaryKey;
        config = internal_1.defineConfig(config, {
            patch: false,
            background: false,
        });
        if (!internal_1.isValidObject(_data)) {
            internal_1.Agile.logger.error(`Item Data of Collection '${this._key}' has to be an valid Object!`);
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(_data, primaryKey)) {
            internal_1.Agile.logger.error(`Collection '${this._key}' Item Data has to contain a primaryKey property called '${this.config.primaryKey}'!`);
            return false;
        }
        const itemKey = _data[primaryKey];
        let item = this.getItem(itemKey, { notExisting: true });
        const wasPlaceholder = (item === null || item === void 0 ? void 0 : item.isPlaceholder) || false;
        const createItem = !item;
        if (!createItem && config.patch)
            item === null || item === void 0 ? void 0 : item.patch(_data, { background: config.background });
        if (!createItem && !config.patch)
            item === null || item === void 0 ? void 0 : item.set(_data, { background: config.background });
        if (createItem) {
            item = new internal_1.Item(this, _data);
            this.data[itemKey] = item;
            this.rebuildGroupsThatIncludeItemKey(itemKey, {
                background: config.background,
            });
        }
        if (createItem || wasPlaceholder)
            this.size++;
        return true;
    }
    rebuildGroupsThatIncludeItemKey(itemKey, config = {}) {
        config = internal_1.defineConfig(config, {
            background: false,
            sideEffects: {
                enabled: true,
                exclude: [],
            },
        });
        for (const groupKey in this.groups) {
            const group = this.getGroup(groupKey);
            if (group === null || group === void 0 ? void 0 : group.has(itemKey)) {
                group === null || group === void 0 ? void 0 : group.ingest({
                    background: config === null || config === void 0 ? void 0 : config.background,
                    force: true,
                    sideEffects: config === null || config === void 0 ? void 0 : config.sideEffects,
                    storage: false,
                });
            }
        }
    }
}
exports.Collection = Collection;
