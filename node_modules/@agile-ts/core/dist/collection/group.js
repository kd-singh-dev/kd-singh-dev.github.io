"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Group = void 0;
const internal_1 = require("../internal");
class Group extends internal_1.State {
    constructor(collection, initialItems, config = {}) {
        super(collection.agileInstance(), initialItems || [], config);
        this._output = [];
        this._items = [];
        this.notFoundItemKeys = [];
        this.collection = () => collection;
        this.addSideEffect(Group.rebuildGroupSideEffectKey, () => this.rebuild());
        this.rebuild();
    }
    get output() {
        internal_1.ComputedTracker.tracked(this.observer);
        return this._output;
    }
    set output(value) {
        this._output = value;
    }
    get items() {
        internal_1.ComputedTracker.tracked(this.observer);
        return this._items.map((item) => item());
    }
    set items(value) {
        this._items = value.map((item) => () => item);
    }
    has(itemKey) {
        return this.value.findIndex((key) => key === itemKey) !== -1;
    }
    get size() {
        return this.value.length;
    }
    remove(itemKeys, config = {}) {
        const _itemKeys = internal_1.normalizeArray(itemKeys);
        const notExistingItemKeysInCollection = [];
        const notExistingItemKeys = [];
        let newGroupValue = internal_1.copy(this.nextStateValue);
        _itemKeys.forEach((itemKey) => {
            if (!newGroupValue.includes(itemKey)) {
                internal_1.Agile.logger.error(`Couldn't find ItemKey '${itemKey}' in Group '${this._key}'!`);
                notExistingItemKeys.push(itemKey);
                notExistingItemKeysInCollection.push(itemKey);
                return;
            }
            if (!this.collection().getItem(itemKey))
                notExistingItemKeysInCollection.push(itemKey);
            newGroupValue = newGroupValue.filter((key) => key !== itemKey);
        });
        if (notExistingItemKeys.length >= _itemKeys.length)
            return this;
        if (notExistingItemKeysInCollection.length >= _itemKeys.length)
            config.background = true;
        this.set(newGroupValue, config);
        return this;
    }
    add(itemKeys, config = {}) {
        const _itemKeys = internal_1.normalizeArray(itemKeys);
        const notExistingItemKeysInCollection = [];
        const existingItemKeys = [];
        let newGroupValue = internal_1.copy(this.nextStateValue);
        config = internal_1.defineConfig(config, {
            method: 'push',
            overwrite: false,
        });
        _itemKeys.forEach((itemKey) => {
            const existsInGroup = newGroupValue.includes(itemKey);
            if (!this.collection().getItem(itemKey))
                notExistingItemKeysInCollection.push(itemKey);
            if (existsInGroup) {
                if (config.overwrite) {
                    newGroupValue = newGroupValue.filter((key) => key !== itemKey);
                }
                else {
                    existingItemKeys.push(itemKey);
                    return;
                }
            }
            newGroupValue[config.method || 'push'](itemKey);
        });
        if (existingItemKeys.length >= _itemKeys.length)
            return this;
        if (notExistingItemKeysInCollection.concat(existingItemKeys).length >=
            _itemKeys.length)
            config.background = true;
        this.set(newGroupValue, internal_1.removeProperties(config, ['method', 'overwrite']));
        return this;
    }
    replace(oldItemKey, newItemKey, config = {}) {
        const newGroupValue = internal_1.copy(this._value);
        newGroupValue.splice(newGroupValue.indexOf(oldItemKey), 1, newItemKey);
        this.set(newGroupValue, config);
        return this;
    }
    persist(keyOrConfig = {}, config = {}) {
        let _config;
        let key;
        if (internal_1.isValidObject(keyOrConfig)) {
            _config = keyOrConfig;
            key = this._key;
        }
        else {
            _config = config || {};
            key = keyOrConfig;
        }
        _config = internal_1.defineConfig(_config, {
            loadValue: true,
            followCollectionPattern: false,
            storageKeys: [],
            defaultStorageKey: null,
        });
        if (_config.followCollectionPersistKeyPattern) {
            key = internal_1.CollectionPersistent.getGroupStorageKey(key || this._key, this.collection()._key);
        }
        super.persist(key, {
            loadValue: _config.loadValue,
            storageKeys: _config.storageKeys,
            defaultStorageKey: _config.defaultStorageKey,
        });
        return this;
    }
    rebuild() {
        const notFoundItemKeys = [];
        const groupItems = [];
        this._value.forEach((itemKey) => {
            const item = this.collection().getItem(itemKey);
            if (item)
                groupItems.push(item);
            else
                notFoundItemKeys.push(itemKey);
        });
        const groupOutput = groupItems.map((item) => {
            return item.getPublicValue();
        });
        if (notFoundItemKeys.length > 0) {
            internal_1.Agile.logger.warn(`Couldn't find some Items in Collection '${this.collection()._key}' (${this._key})`, notFoundItemKeys);
        }
        this.items = groupItems;
        this._output = groupOutput;
        this.notFoundItemKeys = notFoundItemKeys;
        return this;
    }
}
exports.Group = Group;
Group.rebuildGroupSideEffectKey = 'rebuildGroup';
