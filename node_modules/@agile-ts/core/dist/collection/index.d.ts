import { Agile, Item, Group, GroupKey, Selector, SelectorKey, StorageKey, GroupConfigInterface, CollectionPersistent, GroupAddConfigInterface, SideEffectConfigInterface, SelectorConfigInterface } from '../internal';
export declare class Collection<DataType extends object = DefaultItem> {
    agileInstance: () => Agile;
    config: CollectionConfigInterface;
    private initialConfig;
    size: number;
    data: {
        [key: string]: Item<DataType>;
    };
    _key?: CollectionKey;
    isPersisted: boolean;
    persistent: CollectionPersistent<DataType> | undefined;
    groups: {
        [key: string]: Group<DataType>;
    };
    selectors: {
        [key: string]: Selector<DataType>;
    };
    isInstantiated: boolean;
    /**
     * @public
     * Collection - Class that holds a List of Objects with key and causes rerender on subscribed Components
     * @param agileInstance - An instance of Agile
     * @param config - Config
     */
    constructor(agileInstance: Agile, config?: CollectionConfig<DataType>);
    /**
     * @public
     * Set Key/Name of Collection
     */
    set key(value: CollectionKey | undefined);
    /**
     * @public
     * Get Key/Name of Collection
     */
    get key(): CollectionKey | undefined;
    /**
     * @public
     * Set Key/Name of Collection
     * @param value - New Key/Name of Collection
     */
    setKey(value: CollectionKey | undefined): this;
    /**
     * @public
     * Group - Holds Items of this Collection
     * @param initialItems - Initial ItemKeys of Group
     * @param config - Config
     */
    Group(initialItems?: Array<ItemKey>, config?: GroupConfigInterface): Group<DataType>;
    /**
     * @public
     * Selector - Represents an Item of this Collection
     * @param initialKey - Key of Item that the Selector represents
     * @param config - Config
     */
    Selector(initialKey: ItemKey, config?: SelectorConfigInterface): Selector<DataType>;
    /**
     * @internal
     * Instantiates Groups
     */
    initGroups(groups: {
        [key: string]: Group<any>;
    } | string[]): void;
    /**
     * @internal
     * Instantiates Selectors
     */
    initSelectors(selectors: {
        [key: string]: Selector<any>;
    } | string[]): void;
    /**
     * @public
     * Collect Item/s
     * @param data - Data that gets added to Collection
     * @param groupKeys - Add collected Item/s to certain Groups
     * @param config - Config
     */
    collect(data: DataType | Array<DataType>, groupKeys?: GroupKey | Array<GroupKey>, config?: CollectConfigInterface<DataType>): this;
    /**
     * @public
     * Updates Item at provided Key
     * @param itemKey - ItemKey of Item that gets updated
     * @param changes - Changes that will be merged into the Item (flatMerge)
     * @param config - Config
     */
    update(itemKey: ItemKey, changes: DefaultItem | DataType, config?: UpdateConfigInterface): Item<DataType> | undefined;
    /**
     * @public
     * Creates new Group that can hold Items of Collection
     * @param groupKey - Name/Key of Group
     * @param initialItems - Initial ItemKeys of Group
     */
    createGroup(groupKey: GroupKey, initialItems?: Array<ItemKey>): Group<DataType>;
    /**
     * @public
     * Check if Group exists in Collection
     * @param groupKey - Key/Name of Group
     * @param config - Config
     */
    hasGroup(groupKey: GroupKey | undefined, config?: HasConfigInterface): boolean;
    /**
     * @public
     * Get Group by Key/Name
     * @param groupKey - Key/Name of Group
     * @param config - Config
     */
    getGroup(groupKey: GroupKey | undefined, config?: HasConfigInterface): Group<DataType> | undefined;
    /**
     * @public
     * Get Group by Key/Name or a Reference to it if it doesn't exist yet
     * @param groupKey - Name/Key of Group
     */
    getGroupWithReference(groupKey: GroupKey): Group<DataType>;
    /**
     * @public
     * Removes Group by Key/Name
     * @param groupKey - Name/Key of Group
     */
    removeGroup(groupKey: GroupKey): this;
    /**
     * @public
     * Creates new Selector that represents an Item of the Collection
     * @param selectorKey - Name/Key of Selector
     * @param itemKey - Key of Item which the Selector represents
     */
    createSelector(selectorKey: SelectorKey, itemKey: ItemKey): Selector<DataType>;
    /**
     * @public
     * Creates new Selector that represents an Item of the Collection
     * @param itemKey - Key of Item which the Selector represents
     */
    select(itemKey: ItemKey): Selector<DataType>;
    /**
     * @public
     * Check if Selector exists in Collection
     * @param selectorKey - Key/Name of Selector
     * @param config - Config
     */
    hasSelector(selectorKey: SelectorKey | undefined, config?: HasConfigInterface): boolean;
    /**
     * @public
     * Get Selector by Key/Name
     * @param selectorKey - Key/Name of Selector
     * @param config - Config
     */
    getSelector(selectorKey: SelectorKey | undefined, config?: HasConfigInterface): Selector<DataType> | undefined;
    /**
     * @public
     * Get Selector by Key/Name or a Reference to it if it doesn't exist yet
     * @param selectorKey - Name/Key of Selector
     */
    getSelectorWithReference(selectorKey: SelectorKey): Selector<DataType>;
    /**
     * @public
     * Removes Selector by Key/Name
     * @param selectorKey - Name/Key of Selector
     */
    removeSelector(selectorKey: SelectorKey): this;
    /**
     * @public
     * Check if Item exists in Collection
     * @param itemKey - Key/Name of Item
     * @param config - Config
     */
    hasItem(itemKey: ItemKey | undefined, config?: HasConfigInterface): boolean;
    /**
     * @public
     * Get Item by Key/Name
     * @param itemKey - ItemKey of Item
     * @param config - Config
     */
    getItem(itemKey: ItemKey | undefined, config?: HasConfigInterface): Item<DataType> | undefined;
    /**
     * @public
     * Get Item by Key/Name or a Reference to it if it doesn't exist yet
     * @param itemKey - Key/Name of Item
     */
    getItemWithReference(itemKey: ItemKey): Item<DataType>;
    /**
     * @public
     * Get Value of Item by Key/Name
     * @param itemKey - ItemKey of Item that holds the Value
     * @param config - Config
     */
    getItemValue(itemKey: ItemKey | undefined, config?: HasConfigInterface): DataType | undefined;
    /**
     * @public
     * Get all Items of Collection
     * @param config - Config
     */
    getAllItems(config?: HasConfigInterface): Array<Item<DataType>>;
    /**
     * @public
     * Get all Values of Items in a Collection
     * @param config - Config
     */
    getAllItemValues(config?: HasConfigInterface): Array<DataType>;
    /**
     * @public
     * Stores Collection Value into Agile Storage permanently
     * @param config - Config
     */
    persist(config?: CollectionPersistentConfigInterface): this;
    /**
     * @public
     * Stores Collection Value into Agile Storage permanently
     * @param key - Key/Name of created Persistent (Note: Key required if Collection has no set Key!)
     * @param config - Config
     */
    persist(key?: StorageKey, config?: CollectionPersistentConfigInterface): this;
    /**
     * @public
     * Callback Function that gets called if the persisted Value gets loaded into the Collection for the first Time
     * Note: Only useful for persisted Collections!
     * @param callback - Callback Function
     */
    onLoad(callback: (success: boolean) => void): this;
    /**
     * @public
     * Get count of registered Groups in Collection
     */
    getGroupCount(): number;
    /**
     * @public
     * Get count of registered Selectors in Collection
     */
    getSelectorCount(): number;
    /**
     * @public
     * Resets this Collection
     */
    reset(): this;
    /**
     * @public
     * Puts ItemKey/s into Group/s (GroupKey/s)
     * @param itemKeys - ItemKey/s that get added to provided Group/s
     * @param groupKeys - Group/s to which the ItemKey/s get added
     * @param config - Config
     */
    put(itemKeys: ItemKey | Array<ItemKey>, groupKeys: GroupKey | Array<GroupKey>, config?: GroupAddConfigInterface): this;
    /**
     * @internal
     * Updates Key/Name of Item in all Instances (Group, Selector, ..)
     * @param oldItemKey - Old ItemKey
     * @param newItemKey - New ItemKey
     * @param config - Config
     */
    updateItemKey(oldItemKey: ItemKey, newItemKey: ItemKey, config?: UpdateItemKeyConfigInterface): boolean;
    /**
     * @public
     * Gets GroupKeys that contain the passed ItemKey
     * @param itemKey - ItemKey
     */
    getGroupKeysThatHaveItemKey(itemKey: ItemKey): Array<GroupKey>;
    /**
     * @public
     * Remove Items from Collection
     * @param itemKeys - ItemKey/s that get removed
     */
    remove(itemKeys: ItemKey | Array<ItemKey>): {
        fromGroups: (groups: Array<ItemKey> | ItemKey) => Collection<DataType>;
        everywhere: () => Collection<DataType>;
    };
    /**
     * @public
     * Removes Item/s from Group/s
     * @param itemKeys - ItemKey/s that get removed from Group/s
     * @param groupKeys - GroupKey/s of Group/s form which the ItemKey/s will be removed
     */
    removeFromGroups(itemKeys: ItemKey | Array<ItemKey>, groupKeys: GroupKey | Array<GroupKey>): this;
    /**
     * @public
     * Removes Item completely from Collection
     * @param itemKeys - ItemKey/s of Item/s
     */
    removeItems(itemKeys: ItemKey | Array<ItemKey>): this;
    /**
     * @internal
     * Updates existing or creates Item from provided Data
     * @param data - Data
     * @param config - Config
     */
    setData(data: DataType, config?: SetDataConfigInterface): boolean;
    /**
     * @internal
     * Rebuilds Groups that include the provided ItemKey
     * @itemKey - Item Key
     * @config - Config
     */
    rebuildGroupsThatIncludeItemKey(itemKey: ItemKey, config?: RebuildGroupsThatIncludeItemKeyConfigInterface): void;
}
export declare type DefaultItem = Record<string, any>;
export declare type CollectionKey = string | number;
export declare type ItemKey = string | number;
/**
 * @param key - Key/Name of Collection
 * @param groups - Groups of Collection
 * @param selectors - Selectors of Collection
 * @param primaryKey - Name of Property that holds the PrimaryKey (default = id)
 * @param defaultGroupKey - Key/Name of Default Group that holds all collected Items
 * @param initialData - Initial Data of Collection
 */
export interface CreateCollectionConfigInterface<DataType = DefaultItem> {
    groups?: {
        [key: string]: Group<any>;
    } | string[];
    selectors?: {
        [key: string]: Selector<any>;
    } | string[];
    key?: CollectionKey;
    primaryKey?: string;
    defaultGroupKey?: GroupKey;
    initialData?: Array<DataType>;
}
/**
 * @param primaryKey - Name of Property that holds the PrimaryKey (default = id)
 * @param defaultGroupKey - Key/Name of Default Group that holds all collected Items
 */
export interface CollectionConfigInterface {
    primaryKey: string;
    defaultGroupKey: ItemKey;
}
/**
 * @param patch - If Item gets patched into existing Item with the same Id
 * @param method - Way of adding Item to Collection (push, unshift)
 * @param forEachItem - Gets called for each Item that got collected
 * @param background - If collecting an Item happens in the background (-> not causing any rerender)
 * @param select - If collected Items get selected with a Selector
 */
export interface CollectConfigInterface<DataType = any> {
    patch?: boolean;
    method?: 'push' | 'unshift';
    forEachItem?: (data: DataType, key: ItemKey, index: number) => void;
    background?: boolean;
    select?: boolean;
}
/**
 * @param patch - If Data gets merged into the current Data
 * @param background - If updating an Item happens in the background (-> not causing any rerender)
 */
export interface UpdateConfigInterface {
    patch?: boolean | {
        addNewProperties?: boolean;
    };
    background?: boolean;
}
/**
 * @param background - If updating the primaryKey of an Item happens in the background (-> not causing any rerender)
 */
export interface UpdateItemKeyConfigInterface {
    background?: boolean;
}
/**
 * @param background - If assigning a new value happens in the background (-> not causing any rerender)
 * @param force - Force creating and performing Job
 * @param sideEffects - If Side Effects of Group gets executed
 */
export interface RebuildGroupsThatIncludeItemKeyConfigInterface {
    background?: boolean;
    force?: boolean;
    sideEffects?: SideEffectConfigInterface;
}
/**
 * @param notExisting - If placeholder can be found
 */
export interface HasConfigInterface {
    notExisting?: boolean;
}
/**
 * @param loadValue - If Persistent loads the persisted value into the Collection
 * @param storageKeys - Key/Name of Storages which gets used to persist the Collection Value (NOTE: If not passed the default Storage will be used)
 * @param defaultStorageKey - Default Storage Key (if not provided it takes the first index of storageKeys or the AgileTs default Storage)
 */
export interface CollectionPersistentConfigInterface {
    loadValue?: boolean;
    storageKeys?: StorageKey[];
    defaultStorageKey?: StorageKey;
}
/**
 * @param patch - If Data gets patched into existing Item
 * @param background - If assigning Data happens in background
 */
export interface SetDataConfigInterface {
    patch?: boolean;
    background?: boolean;
}
export declare type CollectionConfig<DataType extends object = DefaultItem> = CreateCollectionConfigInterface<DataType> | ((collection: Collection<DataType>) => CreateCollectionConfigInterface<DataType>);
