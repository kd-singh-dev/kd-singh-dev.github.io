"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Computed = void 0;
const internal_1 = require("../internal");
class Computed extends internal_1.State {
    constructor(agileInstance, computeFunction, config = {}) {
        super(agileInstance, computeFunction(), {
            key: config.key,
            dependents: config.dependents,
        });
        this.deps = [];
        this.hardCodedDeps = [];
        config = internal_1.defineConfig(config, {
            computedDeps: [],
        });
        this.agileInstance = () => agileInstance;
        this.computeFunction = computeFunction;
        this.hardCodedDeps = internal_1.extractObservers(config.computedDeps).filter((dep) => dep !== undefined);
        this.deps = this.hardCodedDeps;
        this.recompute({ autodetect: true });
    }
    recompute(config = {}) {
        config = internal_1.defineConfig(config, {
            autodetect: false,
        });
        this.observer.ingestValue(this.compute({ autodetect: config.autodetect }), internal_1.removeProperties(config, ['autodetect']));
        return this;
    }
    updateComputeFunction(computeFunction, deps = [], config = {}) {
        config = internal_1.defineConfig(config, {
            overwriteDeps: true,
            autodetect: true,
        });
        const newDeps = internal_1.extractObservers(deps).filter((dep) => dep !== undefined);
        if (config.overwriteDeps)
            this.hardCodedDeps = newDeps;
        else
            this.hardCodedDeps = this.hardCodedDeps.concat(newDeps);
        this.deps = this.hardCodedDeps;
        this.computeFunction = computeFunction;
        this.recompute(internal_1.removeProperties(config, ['overwriteDeps']));
        return this;
    }
    compute(config = {}) {
        config = internal_1.defineConfig(config, {
            autodetect: true,
        });
        if (config.autodetect)
            internal_1.ComputedTracker.track();
        const computedValue = this.computeFunction();
        if (config.autodetect) {
            const foundDeps = internal_1.ComputedTracker.getTrackedObservers();
            const newDeps = [];
            this.hardCodedDeps.concat(foundDeps).forEach((observer) => {
                newDeps.push(observer);
                observer.depend(this.observer);
            });
            this.deps = newDeps;
        }
        return computedValue;
    }
    patch() {
        internal_1.Agile.logger.error("You can't use patch method on ComputedState!");
        return this;
    }
    persist() {
        internal_1.Agile.logger.error("You can't use persist method on ComputedState!");
        return this;
    }
    invert() {
        internal_1.Agile.logger.error("You can't use invert method on ComputedState!");
        return this;
    }
}
exports.Computed = Computed;
