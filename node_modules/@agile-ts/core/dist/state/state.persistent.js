"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatePersistent = void 0;
const internal_1 = require("../internal");
class StatePersistent extends internal_1.Persistent {
    constructor(state, config = {}) {
        super(state.agileInstance(), {
            instantiate: false,
        });
        config = internal_1.defineConfig(config, {
            instantiate: true,
            storageKeys: [],
            defaultStorageKey: null,
        });
        this.state = () => state;
        this.instantiatePersistent({
            key: config.key,
            storageKeys: config.storageKeys,
            defaultStorageKey: config.defaultStorageKey,
        });
        if (this.ready && config.instantiate)
            this.initialLoading();
    }
    setKey(value) {
        return __awaiter(this, void 0, void 0, function* () {
            const oldKey = this._key;
            const wasReady = this.ready;
            if (value === this._key)
                return;
            this._key = value || internal_1.Persistent.placeHolderKey;
            const isValid = this.validatePersistent();
            if (!wasReady) {
                if (isValid)
                    yield this.initialLoading();
                return;
            }
            yield this.removePersistedValue(oldKey);
            if (isValid)
                yield this.persistValue(value);
        });
    }
    initialLoading() {
        const _super = Object.create(null, {
            initialLoading: { get: () => super.initialLoading }
        });
        return __awaiter(this, void 0, void 0, function* () {
            _super.initialLoading.call(this).then(() => {
                this.state().isPersisted = true;
            });
        });
    }
    loadPersistedValue(storageKey) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.ready)
                return false;
            const _storageKey = storageKey || this._key;
            const loadedValue = yield this.agileInstance().storages.get(_storageKey, this.config.defaultStorageKey);
            if (!loadedValue)
                return false;
            this.state().set(loadedValue, { storage: false });
            yield this.persistValue(_storageKey);
            return true;
        });
    }
    persistValue(storageKey) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.ready)
                return false;
            const _storageKey = storageKey || this._key;
            this.state().addSideEffect(StatePersistent.storeValueSideEffectKey, (instance, config) => {
                this.rebuildStorageSideEffect(this.state(), _storageKey, config);
            }, { weight: 0 });
            this.rebuildStorageSideEffect(this.state(), _storageKey);
            this.isPersisted = true;
            return true;
        });
    }
    removePersistedValue(storageKey) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.ready)
                return false;
            const _storageKey = storageKey || this._key;
            this.state().removeSideEffect(StatePersistent.storeValueSideEffectKey);
            this.agileInstance().storages.remove(_storageKey, this.storageKeys);
            this.isPersisted = false;
            return true;
        });
    }
    formatKey(key) {
        const state = this.state();
        if (!key && state._key)
            return state._key;
        if (!key)
            return;
        if (!state._key)
            state._key = key;
        return key;
    }
    rebuildStorageSideEffect(state, storageKey, config = {}) {
        if (config.storage !== undefined && !config.storage)
            return;
        this.agileInstance().storages.set(storageKey, this.state().getPersistableValue(), this.storageKeys);
    }
}
exports.StatePersistent = StatePersistent;
StatePersistent.storeValueSideEffectKey = 'rebuildStateStorageValue';
