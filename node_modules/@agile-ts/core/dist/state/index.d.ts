/// <reference types="node" />
import { Agile, StorageKey, StateObserver, StatePersistent, Observer, PersistentKey, StateIngestConfigInterface } from '../internal';
export declare class State<ValueType = any> {
    agileInstance: () => Agile;
    _key?: StateKey;
    valueType?: string;
    isSet: boolean;
    isPlaceholder: boolean;
    initialStateValue: ValueType;
    _value: ValueType;
    previousStateValue: ValueType;
    nextStateValue: ValueType;
    observer: StateObserver<ValueType>;
    sideEffects: {
        [key: string]: SideEffectInterface<State<ValueType>>;
    };
    computeValueMethod?: ComputeValueMethod<ValueType>;
    computeExistsMethod: ComputeExistsMethod<ValueType>;
    isPersisted: boolean;
    persistent: StatePersistent | undefined;
    watchers: {
        [key: string]: StateWatcherCallback<ValueType>;
    };
    currentInterval?: NodeJS.Timer | number;
    /**
     * @public
     * State - Class that holds one Value and causes rerender on subscribed Components
     * @param agileInstance - An instance of Agile
     * @param initialValue - Initial Value of State
     * @param config - Config
     */
    constructor(agileInstance: Agile, initialValue: ValueType, config?: StateConfigInterface);
    /**
     * @public
     * Set Value of State
     */
    set value(value: ValueType);
    /**
     * @public
     * Get Value of State
     */
    get value(): ValueType;
    /**
     * @public
     * Set Key/Name of State
     */
    set key(value: StateKey | undefined);
    /**
     * @public
     * Get Key/Name of State
     */
    get key(): StateKey | undefined;
    /**
     * @internal
     * Updates Key/Name of State
     * @param value - New Key/Name of State
     */
    setKey(value: StateKey | undefined): this;
    /**
     * @public
     * Updates Value of State
     * @param value - new State Value
     * @param config - Config
     */
    set(value: ValueType | ((value: ValueType) => ValueType), config?: StateIngestConfigInterface): this;
    /**
     * @internal
     * Ingests nextStateValue, computedValue into Runtime
     * @param config - Config
     */
    ingest(config?: StateIngestConfigInterface): this;
    /**
     * @public
     * Assign primitive type to State Value
     * Note: This function is mainly thought for JS users
     * @param type - wished Type ('String', 'Boolean', 'Array', 'Object', 'Number')
     */
    type(type: any): this;
    /**
     * @public
     * Undoes latest State Value change
     * @param config - Config
     */
    undo(config?: StateIngestConfigInterface): this;
    /**
     * @public
     * Resets State to its initial Value
     * @param config - Config
     */
    reset(config?: StateIngestConfigInterface): this;
    /**
     * @public
     * Patches Object with changes into State Value
     * Note: Only useful if State is an Object
     * @param targetWithChanges - Object that holds changes which get patched into State Value
     * @param config - Config
     */
    patch(targetWithChanges: Object, config?: PatchConfigInterface): this;
    /**
     * @public
     * Watches State and detects State changes
     * @param callback - Callback Function that gets called if the State Value changes
     * @return Key of Watcher
     */
    watch(callback: StateWatcherCallback<ValueType>): string;
    /**
     * @public
     * Watches State and detects State changes
     * @param key - Key/Name of Watcher Function
     * @param callback - Callback Function that gets called if the State Value changes
     */
    watch(key: string, callback: StateWatcherCallback<ValueType>): this;
    /**
     * @public
     * Removes Watcher at given Key
     * @param key - Key of Watcher that gets removed
     */
    removeWatcher(key: string): this;
    /**
     * @public
     * Creates a Watcher that gets once called when the State Value changes for the first time and than destroys itself
     * @param callback - Callback Function that gets called if the State Value changes
     */
    onInaugurated(callback: StateWatcherCallback<ValueType>): this;
    /**
     * @public
     * Checks if watcher at given Key exists
     * @param key - Key/Name of Watcher
     */
    hasWatcher(key: string): boolean;
    /**
     * @public
     * Stores State Value into Agile Storage permanently
     * @param config - Config
     */
    persist(config?: StatePersistentConfigInterface): this;
    /**
     * @public
     * Stores State Value into Agile Storage permanently
     * @param key - Key/Name of created Persistent (Note: Key required if State has no set Key!)
     * @param config - Config
     */
    persist(key?: PersistentKey, config?: StatePersistentConfigInterface): this;
    /**
     * @public
     * Callback Function that gets called if the persisted Value gets loaded into the State for the first Time
     * Note: Only useful for persisted States!
     * @param callback - Callback Function
     */
    onLoad(callback: (success: boolean) => void): this;
    /**
     * @public
     * Calls callback at certain intervals in milliseconds and assigns the callback return value to the State
     * @param callback- Callback that is called on each interval and should return the new State value
     * @param ms - The intervals in milliseconds
     */
    interval(callback: (value: ValueType) => ValueType, ms?: number): this;
    /**
     * @public
     * Clears the current Interval
     */
    clearInterval(): void;
    /**
     * @public
     * Creates fresh copy of State Value (-> No reference to State Value)
     */
    copy(): ValueType;
    /**
     * @public
     * Checks if State exists
     */
    get exists(): boolean;
    /**
     * @public
     * Function that computes the exists status of the State
     * @param method - Computed Function
     */
    computeExists(method: ComputeExistsMethod<ValueType>): this;
    /**
     * @public
     * Equivalent to ===
     * @param value - Value that gets checked if its equals to the State Value
     */
    is(value: ValueType): boolean;
    /**
     * @public
     * Equivalent to !==
     * @param value - Value that gets checked if its not equals to the State Value
     */
    isNot(value: ValueType): boolean;
    /**
     * @public
     * Inverts State Value
     * Note: Only useful with boolean based States
     */
    invert(): this;
    /**
     * @public
     * Function that recomputes State Value if it changes
     * @param method - Computed Function
     */
    computeValue(method: ComputeValueMethod<ValueType>): this;
    /**
     * @internal
     * Adds SideEffect to State
     * @param key - Key/Name of SideEffect
     * @param callback - Callback Function that gets called on every State Value change
     * @param config - Config
     */
    addSideEffect<Instance extends State<ValueType>>(key: string, callback: SideEffectFunctionType<Instance>, config?: AddSideEffectConfigInterface): this;
    /**
     * @internal
     * Removes SideEffect at given Key
     * @param key - Key of the SideEffect that gets removed
     */
    removeSideEffect(key: string): this;
    /**
     * @internal
     * Checks if sideEffect at given Key exists
     * @param key - Key of SideEffect
     */
    hasSideEffect(key: string): boolean;
    /**
     * @internal
     * Checks if Value has correct valueType (js)
     * Note: If no valueType set, it returns true
     * @param value - Value that gets checked for its correct Type
     */
    hasCorrectType(value: any): boolean;
    /**
     * @internal
     * Returns public Value of State
     */
    getPublicValue(): ValueType;
    /**
     * @internal
     * Returns Value that gets written into the Agile Storage
     */
    getPersistableValue(): any;
}
export declare type StateKey = string | number;
/**
 * @param key - Key/Name of State
 * @param deps - Initial deps of State
 * @param isPlaceholder - If State is initially a Placeholder
 */
export interface StateConfigInterface {
    key?: StateKey;
    dependents?: Array<Observer>;
    isPlaceholder?: boolean;
}
/**
 * @param addNewProperties - If new Properties gets added to the State Value
 */
export interface PatchConfigInterface extends StateIngestConfigInterface {
    addNewProperties?: boolean;
}
/**
 * @param loadValue - If Persistent loads the persisted value into the State
 * @param storageKeys - Key/Name of Storages which gets used to persist the State Value (NOTE: If not passed the default Storage will be used)
 * @param defaultStorageKey - Default Storage Key (if not provided it takes the first index of storageKeys or the AgileTs default Storage)
 */
export interface StatePersistentConfigInterface {
    loadValue?: boolean;
    storageKeys?: StorageKey[];
    defaultStorageKey?: StorageKey;
}
export declare type StateWatcherCallback<T = any> = (value: T, key: string) => void;
export declare type ComputeValueMethod<T = any> = (value: T) => T;
export declare type ComputeExistsMethod<T = any> = (value: T) => boolean;
export declare type SideEffectFunctionType<Instance extends State<any>> = (instance: Instance, properties?: {
    [key: string]: any;
}) => void;
/**
 * @param callback - Callback Function that gets called on every State Value change
 * @param weight - When the sideEffect gets executed. The higher, the earlier it gets executed.
 */
export interface SideEffectInterface<Instance extends State<any>> {
    callback: SideEffectFunctionType<Instance>;
    weight: number;
}
/**
 * @param weight - When the sideEffect gets executed. The higher, the earlier it gets executed.
 */
export interface AddSideEffectConfigInterface {
    weight?: number;
}
