"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.State = void 0;
const internal_1 = require("../internal");
class State {
    constructor(agileInstance, initialValue, config = {}) {
        this.isSet = false;
        this.isPlaceholder = false;
        this.sideEffects = {};
        this.isPersisted = false;
        this.watchers = {};
        config = internal_1.defineConfig(config, {
            dependents: [],
            isPlaceholder: false,
        });
        this.agileInstance = () => agileInstance;
        this._key = config.key;
        this.observer = new internal_1.StateObserver(this, {
            key: config.key,
            dependents: config.dependents,
        });
        this.initialStateValue = internal_1.copy(initialValue);
        this._value = internal_1.copy(initialValue);
        this.previousStateValue = internal_1.copy(initialValue);
        this.nextStateValue = internal_1.copy(initialValue);
        this.isPlaceholder = true;
        this.computeExistsMethod = (v) => {
            return v != null;
        };
        if (!config.isPlaceholder)
            this.set(initialValue, { overwrite: true });
    }
    set value(value) {
        this.set(value);
    }
    get value() {
        internal_1.ComputedTracker.tracked(this.observer);
        return this._value;
    }
    set key(value) {
        this.setKey(value);
    }
    get key() {
        return this._key;
    }
    setKey(value) {
        var _a, _b;
        const oldKey = this._key;
        this._key = value;
        this.observer._key = value;
        if (value && ((_a = this.persistent) === null || _a === void 0 ? void 0 : _a._key) === oldKey)
            (_b = this.persistent) === null || _b === void 0 ? void 0 : _b.setKey(value);
        return this;
    }
    set(value, config = {}) {
        config = internal_1.defineConfig(config, {
            force: false,
        });
        const _value = internal_1.isFunction(value)
            ? value(internal_1.copy(this._value))
            : value;
        if (!this.hasCorrectType(_value)) {
            const message = `Incorrect type (${typeof _value}) was provided.`;
            if (!config.force) {
                internal_1.Agile.logger.error(message);
                return this;
            }
            internal_1.Agile.logger.warn(message);
        }
        this.observer.ingestValue(_value, config);
        return this;
    }
    ingest(config = {}) {
        this.observer.ingest(config);
        return this;
    }
    type(type) {
        const supportedTypes = ['String', 'Boolean', 'Array', 'Object', 'Number'];
        if (!supportedTypes.includes(type.name)) {
            internal_1.Agile.logger.warn(`'${type}' is not supported! Supported types: String, Boolean, Array, Object, Number`);
            return this;
        }
        this.valueType = type.name.toLowerCase();
        return this;
    }
    undo(config = {}) {
        this.set(this.previousStateValue, config);
        return this;
    }
    reset(config = {}) {
        this.set(this.initialStateValue, config);
        return this;
    }
    patch(targetWithChanges, config = {}) {
        config = internal_1.defineConfig(config, {
            addNewProperties: true,
        });
        if (!internal_1.isValidObject(this.nextStateValue)) {
            internal_1.Agile.logger.error("You can't use the patch method on a non object based States!");
            return this;
        }
        if (!internal_1.isValidObject(targetWithChanges)) {
            internal_1.Agile.logger.error('TargetWithChanges has to be an Object!');
            return this;
        }
        this.nextStateValue = internal_1.flatMerge(internal_1.copy(this.nextStateValue), targetWithChanges, { addNewProperties: config.addNewProperties });
        this.ingest(internal_1.removeProperties(config, ['addNewProperties']));
        return this;
    }
    watch(keyOrCallback, callback) {
        const generateKey = internal_1.isFunction(keyOrCallback);
        let _callback;
        let key;
        if (generateKey) {
            key = internal_1.generateId();
            _callback = keyOrCallback;
        }
        else {
            key = keyOrCallback;
            _callback = callback;
        }
        if (!internal_1.isFunction(_callback)) {
            internal_1.Agile.logger.error('A Watcher Callback Function has to be typeof Function!');
            return this;
        }
        if (this.watchers[key]) {
            internal_1.Agile.logger.error(`Watcher Callback Function with the key/name '${key}' already exists!`);
            return this;
        }
        this.watchers[key] = _callback;
        return generateKey ? key : this;
    }
    removeWatcher(key) {
        delete this.watchers[key];
        return this;
    }
    onInaugurated(callback) {
        const watcherKey = 'InauguratedWatcherKey';
        this.watch(watcherKey, (value, key) => {
            callback(value, key);
            this.removeWatcher(watcherKey);
        });
        return this;
    }
    hasWatcher(key) {
        return !!this.watchers[key];
    }
    persist(keyOrConfig = {}, config = {}) {
        let _config;
        let key;
        if (internal_1.isValidObject(keyOrConfig)) {
            _config = keyOrConfig;
            key = this._key;
        }
        else {
            _config = config || {};
            key = keyOrConfig;
        }
        _config = internal_1.defineConfig(_config, {
            loadValue: true,
            storageKeys: [],
            defaultStorageKey: null,
        });
        if (this.persistent) {
            internal_1.Agile.logger.warn(`By persisting the State '${this._key}' twice you overwrite the old Persistent Instance!`, this.persistent);
        }
        this.persistent = new internal_1.StatePersistent(this, {
            instantiate: _config.loadValue,
            storageKeys: _config.storageKeys,
            key: key,
            defaultStorageKey: _config.defaultStorageKey,
        });
        return this;
    }
    onLoad(callback) {
        if (!this.persistent) {
            internal_1.Agile.logger.error(`Please make sure you persist the State '${this._key}' before using the 'onLoad' function!`);
            return this;
        }
        this.persistent.onLoad = callback;
        if (this.isPersisted)
            callback(true);
        return this;
    }
    interval(callback, ms) {
        if (this.currentInterval) {
            internal_1.Agile.logger.warn(`You can only have one interval active!`, this.currentInterval);
            return this;
        }
        this.currentInterval = setInterval(() => {
            this.set(callback(this._value));
        }, ms !== null && ms !== void 0 ? ms : 1000);
        return this;
    }
    clearInterval() {
        if (this.currentInterval) {
            clearInterval(this.currentInterval);
            delete this.currentInterval;
        }
    }
    copy() {
        return internal_1.copy(this.value);
    }
    get exists() {
        return !this.isPlaceholder && this.computeExistsMethod(this.value);
    }
    computeExists(method) {
        if (!internal_1.isFunction(method)) {
            internal_1.Agile.logger.error(`A 'computeExistsMethod' has to be a function!`);
            return this;
        }
        this.computeExistsMethod = method;
        return this;
    }
    is(value) {
        return internal_1.equal(value, this.value);
    }
    isNot(value) {
        return internal_1.notEqual(value, this.value);
    }
    invert() {
        if (typeof this._value === 'boolean') {
            this.set(!this._value);
        }
        else {
            internal_1.Agile.logger.error('You can only invert boolean based States!');
        }
        return this;
    }
    computeValue(method) {
        if (!internal_1.isFunction(method)) {
            internal_1.Agile.logger.error(`A 'computeValueMethod' has to be a function!`);
            return this;
        }
        this.computeValueMethod = method;
        this.set(method(this.nextStateValue));
        return this;
    }
    addSideEffect(key, callback, config = {}) {
        config = internal_1.defineConfig(config, {
            weight: 10,
        });
        if (!internal_1.isFunction(callback)) {
            internal_1.Agile.logger.error('A sideEffect function has to be a function!');
            return this;
        }
        this.sideEffects[key] = {
            callback: callback,
            weight: config.weight,
        };
        return this;
    }
    removeSideEffect(key) {
        delete this.sideEffects[key];
        return this;
    }
    hasSideEffect(key) {
        return !!this.sideEffects[key];
    }
    hasCorrectType(value) {
        if (!this.valueType)
            return true;
        const type = typeof value;
        return type === this.valueType;
    }
    getPublicValue() {
        if (this['output'] !== undefined)
            return this['output'];
        return this._value;
    }
    getPersistableValue() {
        return this._value;
    }
}
exports.State = State;
