"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateObserver = void 0;
const internal_1 = require("../internal");
class StateObserver extends internal_1.Observer {
    constructor(state, config = {}) {
        super(state.agileInstance(), Object.assign(Object.assign({}, config), { value: state._value }));
        this.state = () => state;
        this.nextStateValue = internal_1.copy(state._value);
    }
    ingest(config = {}) {
        const state = this.state();
        let newStateValue;
        if (state instanceof internal_1.Computed)
            newStateValue = state.compute();
        else
            newStateValue = state.nextStateValue;
        this.ingestValue(newStateValue, config);
    }
    ingestValue(newStateValue, config = {}) {
        const state = this.state();
        config = internal_1.defineConfig(config, {
            perform: true,
            background: false,
            sideEffects: {
                enabled: true,
                exclude: [],
            },
            force: false,
            storage: true,
            overwrite: false,
        });
        if (state.isPlaceholder) {
            config.force = true;
            config.overwrite = true;
        }
        this.nextStateValue = state.computeValueMethod
            ? internal_1.copy(state.computeValueMethod(newStateValue))
            : internal_1.copy(newStateValue);
        if (internal_1.equal(state._value, this.nextStateValue) && !config.force)
            return;
        const job = new internal_1.StateRuntimeJob(this, {
            storage: config.storage,
            sideEffects: config.sideEffects,
            force: config.force,
            background: config.background,
            overwrite: config.overwrite,
            key: config.key || this._key,
        });
        this.agileInstance().runtime.ingest(job, {
            perform: config.perform,
        });
    }
    perform(job) {
        const state = job.observer.state();
        const previousValue = internal_1.copy(state.getPublicValue());
        state.previousStateValue = internal_1.copy(state._value);
        state._value = internal_1.copy(job.observer.nextStateValue);
        state.nextStateValue = internal_1.copy(job.observer.nextStateValue);
        if (job.config.overwrite) {
            state.initialStateValue = internal_1.copy(state._value);
            state.previousStateValue = internal_1.copy(state._value);
            state.isPlaceholder = false;
        }
        state.isSet = internal_1.notEqual(state._value, state.initialStateValue);
        this.sideEffects(job);
        job.observer.value = internal_1.copy(state.getPublicValue());
        job.observer.previousValue = previousValue;
    }
    sideEffects(job) {
        var _a, _b, _c;
        const state = job.observer.state();
        for (const watcherKey in state.watchers)
            if (internal_1.isFunction(state.watchers[watcherKey]))
                state.watchers[watcherKey](state.getPublicValue(), watcherKey);
        if ((_b = (_a = job.config) === null || _a === void 0 ? void 0 : _a.sideEffects) === null || _b === void 0 ? void 0 : _b.enabled) {
            const sideEffectArray = internal_1.createArrayFromObject(state.sideEffects);
            sideEffectArray.sort(function (a, b) {
                return b.instance.weight - a.instance.weight;
            });
            for (const sideEffect of sideEffectArray) {
                if (internal_1.isFunction(sideEffect.instance.callback)) {
                    if (!((_c = job.config.sideEffects.exclude) === null || _c === void 0 ? void 0 : _c.includes(sideEffect.key)))
                        sideEffect.instance.callback(job.observer.state(), job.config);
                }
            }
        }
    }
}
exports.StateObserver = StateObserver;
