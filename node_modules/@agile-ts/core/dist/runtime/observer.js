"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Observer = void 0;
const internal_1 = require("../internal");
class Observer {
    constructor(agileInstance, config = {}) {
        var _a, _b;
        this.dependents = new Set();
        this.subs = new Set();
        config = internal_1.defineConfig(config, {
            dependents: [],
            subs: [],
        });
        this.agileInstance = () => agileInstance;
        this._key = config.key;
        this.value = config.value;
        this.previousValue = config.value;
        (_a = config.dependents) === null || _a === void 0 ? void 0 : _a.forEach((observer) => this.depend(observer));
        (_b = config.subs) === null || _b === void 0 ? void 0 : _b.forEach((subscriptionContainer) => this.subscribe(subscriptionContainer));
    }
    set key(value) {
        this._key = value;
    }
    get key() {
        return this._key;
    }
    ingest(config = {}) {
        config = internal_1.defineConfig(config, {
            perform: true,
            background: false,
            sideEffects: {
                enabled: true,
                exclude: [],
            },
            force: false,
        });
        const job = new internal_1.RuntimeJob(this, {
            force: config.force,
            sideEffects: config.sideEffects,
            background: config.background,
            key: config.key || this._key,
        });
        this.agileInstance().runtime.ingest(job, {
            perform: config.perform,
        });
    }
    perform(job) {
        internal_1.Agile.logger.warn("Perform function isn't Set in Observer! Be aware that Observer is no stand alone class!");
    }
    depend(observer) {
        if (!this.dependents.has(observer))
            this.dependents.add(observer);
    }
    subscribe(subscriptionContainer) {
        if (!this.subs.has(subscriptionContainer)) {
            this.subs.add(subscriptionContainer);
            subscriptionContainer.subs.add(this);
        }
    }
    unsubscribe(subscriptionContainer) {
        if (this.subs.has(subscriptionContainer)) {
            this.subs.delete(subscriptionContainer);
            subscriptionContainer.subs.delete(this);
        }
    }
}
exports.Observer = Observer;
