"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubController = void 0;
const internal_1 = require("../../internal");
class SubController {
    constructor(agileInstance) {
        this.componentSubs = new Set();
        this.callbackSubs = new Set();
        this.mountedComponents = new Set();
        this.agileInstance = () => agileInstance;
    }
    subscribeWithSubsObject(integrationInstance, subs = {}, config = {}) {
        const props = {};
        const subsArray = [];
        for (const key in subs)
            subsArray.push(subs[key]);
        const subscriptionContainer = this.registerSubscription(integrationInstance, subsArray, config);
        subscriptionContainer.isObjectBased = true;
        subscriptionContainer.subsObject = subs;
        for (const key in subs) {
            const observer = subs[key];
            observer.subscribe(subscriptionContainer);
            if (observer.value)
                props[key] = observer.value;
        }
        return {
            subscriptionContainer: subscriptionContainer,
            props: props,
        };
    }
    subscribeWithSubsArray(integrationInstance, subs = [], config = {}) {
        const subscriptionContainer = this.registerSubscription(integrationInstance, subs, config);
        subs.forEach((observer) => observer.subscribe(subscriptionContainer));
        return subscriptionContainer;
    }
    unsubscribe(subscriptionInstance) {
        const unsub = (subscriptionContainer) => {
            subscriptionContainer.ready = false;
            subscriptionContainer.subs.forEach((observer) => {
                observer.unsubscribe(subscriptionContainer);
            });
        };
        if (subscriptionInstance instanceof internal_1.CallbackSubscriptionContainer) {
            unsub(subscriptionInstance);
            this.callbackSubs.delete(subscriptionInstance);
            internal_1.Agile.logger.if
                .tag(['runtime', 'subscription'])
                .info('Unregistered Callback based Subscription ', subscriptionInstance);
            return;
        }
        if (subscriptionInstance instanceof internal_1.ComponentSubscriptionContainer) {
            unsub(subscriptionInstance);
            this.componentSubs.delete(subscriptionInstance);
            internal_1.Agile.logger.if
                .tag(['runtime', 'subscription'])
                .info('Unregistered Component based Subscription ', subscriptionInstance);
            return;
        }
        if (subscriptionInstance.componentSubscriptionContainer) {
            unsub(subscriptionInstance.componentSubscriptionContainer);
            this.componentSubs.delete(subscriptionInstance.componentSubscriptionContainer);
            internal_1.Agile.logger.if
                .tag(['runtime', 'subscription'])
                .info('Unregistered Component based Subscription ', subscriptionInstance);
            return;
        }
        if (subscriptionInstance.componentSubscriptionContainers &&
            Array.isArray(subscriptionInstance.componentSubscriptionContainers)) {
            subscriptionInstance.componentSubscriptionContainers.forEach((subContainer) => {
                unsub(subContainer);
                this.componentSubs.delete(subContainer);
                internal_1.Agile.logger.if
                    .tag(['runtime', 'subscription'])
                    .info('Unregistered Component based Subscription ', subscriptionInstance);
            });
            return;
        }
        internal_1.Agile.logger.if
            .tag(['runtime', 'subscription'])
            .warn(`Couldn't find anything to unregister in `, subscriptionInstance);
        return;
    }
    registerSubscription(integrationInstance, subs = [], config = {}) {
        if (internal_1.isFunction(integrationInstance))
            return this.registerCallbackSubscription(integrationInstance, subs, config);
        return this.registerComponentSubscription(integrationInstance, subs, config);
    }
    registerComponentSubscription(componentInstance, subs = [], config = {}) {
        const componentSubscriptionContainer = new internal_1.ComponentSubscriptionContainer(componentInstance, subs, config);
        this.componentSubs.add(componentSubscriptionContainer);
        if (this.agileInstance().config.waitForMount) {
            if (this.mountedComponents.has(componentInstance))
                componentSubscriptionContainer.ready = true;
        }
        else
            componentSubscriptionContainer.ready = true;
        if (componentInstance.componentSubscriptionContainers &&
            Array.isArray(componentInstance.componentSubscriptionContainers))
            componentInstance.componentSubscriptionContainers.push(componentSubscriptionContainer);
        else
            componentInstance.componentSubscriptionContainer = componentSubscriptionContainer;
        internal_1.Agile.logger.if
            .tag(['runtime', 'subscription'])
            .info('Registered Component based Subscription ', componentSubscriptionContainer);
        return componentSubscriptionContainer;
    }
    registerCallbackSubscription(callbackFunction, subs = [], config = {}) {
        const callbackSubscriptionContainer = new internal_1.CallbackSubscriptionContainer(callbackFunction, subs, config);
        this.callbackSubs.add(callbackSubscriptionContainer);
        callbackSubscriptionContainer.ready = true;
        internal_1.Agile.logger.if
            .tag(['runtime', 'subscription'])
            .info('Registered Callback based Subscription ', callbackSubscriptionContainer);
        return callbackSubscriptionContainer;
    }
    mount(componentInstance) {
        if (componentInstance.componentSubscriptionContainer)
            componentInstance.componentSubscriptionContainer.ready = true;
        this.mountedComponents.add(componentInstance);
    }
    unmount(componentInstance) {
        if (componentInstance.componentSubscriptionContainer)
            componentInstance.componentSubscriptionContainer.ready = false;
        this.mountedComponents.delete(componentInstance);
    }
}
exports.SubController = SubController;
