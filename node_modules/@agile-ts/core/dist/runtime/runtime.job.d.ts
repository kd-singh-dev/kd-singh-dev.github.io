import { Observer, SubscriptionContainer } from '../internal';
export declare class RuntimeJob<ObserverType extends Observer = Observer> {
    _key?: RuntimeJobKey;
    config: RuntimeJobConfigInterface;
    observer: ObserverType;
    rerender: boolean;
    performed: boolean;
    subscriptionContainersToUpdate: Set<SubscriptionContainer>;
    triesToUpdate: number;
    /**
     * @internal
     * Job - Represents Observer that gets performed by the Runtime
     * @param observer - Observer
     * @param config - Config
     */
    constructor(observer: ObserverType, config?: CreateRuntimeJobConfigInterface);
    get key(): RuntimeJobKey | undefined;
    set key(value: RuntimeJobKey | undefined);
}
export declare type RuntimeJobKey = string | number;
/**
 * @param key - Key/Name of RuntimeJob
 */
export interface CreateRuntimeJobConfigInterface extends RuntimeJobConfigInterface {
    key?: RuntimeJobKey;
}
/**
 * @param background - If Job gets executed in the background -> not causing any rerender
 * @param sideEffects - If SideEffects get executed
 * @param force - Force performing Job
 * @param numberOfTriesToUpdate - How often the runtime should try to update not ready SubscriptionContainers of this Job
 * If 'null' the runtime tries to update the not ready SubscriptionContainer until they are ready (infinite).
 * But be aware that this can lead to an overflow of 'old' Jobs after some time. (affects performance)
 */
export interface RuntimeJobConfigInterface {
    background?: boolean;
    sideEffects?: SideEffectConfigInterface;
    force?: boolean;
    numberOfTriesToUpdate?: number | null;
}
/**
 * @param enabled - If SideEffects get executed
 * @param exclude - SideEffect at Keys that doesn't get executed
 */
export interface SideEffectConfigInterface {
    enabled?: boolean;
    exclude?: string[];
}
