"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runtime = void 0;
const internal_1 = require("../internal");
class Runtime {
    constructor(agileInstance) {
        this.currentJob = null;
        this.jobQueue = [];
        this.notReadyJobsToRerender = new Set();
        this.jobsToRerender = [];
        this.agileInstance = () => agileInstance;
    }
    ingest(job, config = {}) {
        config = internal_1.defineConfig(config, {
            perform: true,
        });
        this.jobQueue.push(job);
        internal_1.Agile.logger.if.tag(['runtime']).info(`Created Job '${job._key}'`, job);
        if (config.perform) {
            const performJob = this.jobQueue.shift();
            if (performJob)
                this.perform(performJob);
        }
    }
    perform(job) {
        this.currentJob = job;
        job.observer.perform(job);
        job.performed = true;
        job.observer.dependents.forEach((observer) => observer.ingest({ perform: false }));
        if (job.rerender)
            this.jobsToRerender.push(job);
        this.currentJob = null;
        internal_1.Agile.logger.if.tag(['runtime']).info(`Completed Job '${job._key}'`, job);
        if (this.jobQueue.length > 0) {
            const performJob = this.jobQueue.shift();
            if (performJob)
                this.perform(performJob);
        }
        else {
            if (this.jobsToRerender.length > 0) {
                setTimeout(() => {
                    this.updateSubscribers();
                });
            }
        }
    }
    updateSubscribers() {
        if (!this.agileInstance().hasIntegration()) {
            this.jobsToRerender = [];
            this.notReadyJobsToRerender = new Set();
            return false;
        }
        if (this.jobsToRerender.length <= 0 &&
            this.notReadyJobsToRerender.size <= 0)
            return false;
        const subscriptionsToUpdate = new Set();
        const jobsToRerender = this.jobsToRerender.concat(Array.from(this.notReadyJobsToRerender));
        this.notReadyJobsToRerender = new Set();
        this.jobsToRerender = [];
        jobsToRerender.forEach((job) => {
            job.subscriptionContainersToUpdate.forEach((subscriptionContainer) => {
                if (!subscriptionContainer.ready) {
                    if (!job.config.numberOfTriesToUpdate ||
                        job.triesToUpdate < job.config.numberOfTriesToUpdate) {
                        job.triesToUpdate++;
                        this.notReadyJobsToRerender.add(job);
                        internal_1.Agile.logger.warn("SubscriptionContainer/Component isn't ready to rerender!", subscriptionContainer);
                    }
                    else {
                        internal_1.Agile.logger.warn(`Job with not ready SubscriptionContainer/Component was removed from the runtime after ${job.config.numberOfTriesToUpdate} tries to avoid an overflow.`, subscriptionContainer);
                    }
                    return;
                }
                if (subscriptionContainer.isObjectBased)
                    this.handleObjectBasedSubscription(subscriptionContainer, job);
                const updateSubscriptionContainer = subscriptionContainer.proxyBased
                    ? this.handleProxyBasedSubscription(subscriptionContainer, job)
                    : true;
                if (updateSubscriptionContainer)
                    subscriptionsToUpdate.add(subscriptionContainer);
                job.subscriptionContainersToUpdate.delete(subscriptionContainer);
            });
        });
        if (subscriptionsToUpdate.size <= 0)
            return false;
        subscriptionsToUpdate.forEach((subscriptionContainer) => {
            if (subscriptionContainer instanceof internal_1.CallbackSubscriptionContainer)
                subscriptionContainer.callback();
            if (subscriptionContainer instanceof internal_1.ComponentSubscriptionContainer)
                this.agileInstance().integrations.update(subscriptionContainer.component, this.getObjectBasedProps(subscriptionContainer));
        });
        internal_1.Agile.logger.if
            .tag(['runtime'])
            .info('Updated/Rerendered Subscriptions', subscriptionsToUpdate);
        return true;
    }
    handleObjectBasedSubscription(subscriptionContainer, job) {
        let foundKey = null;
        if (!subscriptionContainer.isObjectBased)
            return;
        for (const key in subscriptionContainer.subsObject)
            if (subscriptionContainer.subsObject[key] === job.observer)
                foundKey = key;
        if (foundKey)
            subscriptionContainer.observerKeysToUpdate.push(foundKey);
    }
    getObjectBasedProps(subscriptionContainer) {
        var _a;
        const props = {};
        if (subscriptionContainer.subsObject)
            for (const updatedKey of subscriptionContainer.observerKeysToUpdate)
                props[updatedKey] = (_a = subscriptionContainer.subsObject[updatedKey]) === null || _a === void 0 ? void 0 : _a.value;
        subscriptionContainer.observerKeysToUpdate = [];
        return props;
    }
    handleProxyBasedSubscription(subscriptionContainer, job) {
        if (!subscriptionContainer.proxyBased ||
            !job.observer._key ||
            !subscriptionContainer.proxyKeyMap[job.observer._key])
            return true;
        const paths = subscriptionContainer.proxyKeyMap[job.observer._key].paths;
        if (paths) {
            for (const path of paths) {
                let newValue = job.observer.value;
                let newValueDeepness = 0;
                for (const branch of path) {
                    if (!internal_1.isValidObject(newValue))
                        break;
                    newValue = newValue[branch];
                    newValueDeepness++;
                }
                let previousValue = job.observer.previousValue;
                let previousValueDeepness = 0;
                for (const branch of path) {
                    if (!internal_1.isValidObject(previousValue))
                        break;
                    previousValue = previousValue[branch];
                    previousValueDeepness++;
                }
                if (internal_1.notEqual(newValue, previousValue) ||
                    newValueDeepness !== previousValueDeepness) {
                    return true;
                }
            }
        }
        return false;
    }
}
exports.Runtime = Runtime;
