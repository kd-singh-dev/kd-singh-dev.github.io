"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Event = void 0;
const core_1 = require("@agile-ts/core");
const internal_1 = require("./internal");
class Event {
    constructor(agileInstance, config = {}) {
        this.uses = 0;
        this.callbacks = {};
        this.enabled = true;
        this.queue = [];
        this.agileInstance = () => agileInstance;
        config = core_1.defineConfig(config, {
            enabled: true,
            rerender: false,
            maxUses: undefined,
            delay: undefined,
            overlap: false,
            dependents: [],
        });
        this._key = config.key;
        this.observer = new internal_1.EventObserver(this, {
            key: config.key,
            dependents: config.dependents,
        });
        this.enabled = config.enabled;
        this.config = {
            rerender: config.rerender,
            delay: config.delay,
            maxUses: config.maxUses,
            overlap: config.overlap,
        };
        this.initialConfig = config;
    }
    set key(value) {
        this.setKey(value);
    }
    get key() {
        return this._key;
    }
    setKey(value) {
        this._key = value;
        this.observer._key = value;
        return this;
    }
    on(keyOrCallback, callback) {
        const generateKey = core_1.isFunction(keyOrCallback);
        let _callback;
        let key;
        if (generateKey) {
            key = core_1.generateId();
            _callback = keyOrCallback;
        }
        else {
            key = keyOrCallback;
            _callback = callback;
        }
        if (!core_1.isFunction(_callback)) {
            core_1.Agile.logger.error('A Event Callback Function has to be typeof Function!');
            return this;
        }
        if (this.callbacks[key]) {
            core_1.Agile.logger.error(`Event Callback Function with the key/name '${key}' already exists!`);
            return this;
        }
        this.callbacks[key] = _callback;
        return generateKey ? key : this;
    }
    trigger(payload, keys) {
        if (!this.enabled)
            return this;
        if (this.config.delay)
            this.delayedTrigger(payload, this.config.delay, keys);
        else
            this.normalTrigger(payload, keys);
        return this;
    }
    disable() {
        this.enabled = false;
        return this;
    }
    enable() {
        this.enabled = true;
        return this;
    }
    reset() {
        this.enabled = this.initialConfig.enabled;
        this.uses = 0;
        if (this.currentTimeout) {
            clearTimeout(this.currentTimeout);
            this.currentTimeout = undefined;
        }
        return this;
    }
    removeCallback(key) {
        delete this.callbacks[key];
        return this;
    }
    normalTrigger(payload, keys) {
        if (!keys) {
            for (const key in this.callbacks)
                this.callbacks[key](payload);
        }
        else {
            for (const key of keys) {
                if (this.callbacks[key])
                    this.callbacks[key](payload);
            }
        }
        if (this.config.rerender)
            this.observer.ingest();
        this.uses++;
        if (this.config.maxUses && this.uses >= this.config.maxUses)
            this.disable();
    }
    delayedTrigger(payload, delay, keys) {
        const eventJob = new internal_1.EventJob(payload, keys);
        if (this.config.overlap) {
            setTimeout(() => {
                this.normalTrigger(eventJob.payload, eventJob.keys);
            }, delay);
            return;
        }
        if (this.currentTimeout !== undefined) {
            if (payload)
                this.queue.push(eventJob);
            return;
        }
        const looper = (eventJob) => {
            this.currentTimeout = setTimeout(() => {
                this.currentTimeout = undefined;
                this.normalTrigger(eventJob.payload, eventJob.keys);
                if (this.queue.length > 0) {
                    const nextEventJob = this.queue.shift();
                    if (nextEventJob)
                        looper(nextEventJob);
                }
            }, delay);
        };
        looper(eventJob);
        return;
    }
}
exports.Event = Event;
