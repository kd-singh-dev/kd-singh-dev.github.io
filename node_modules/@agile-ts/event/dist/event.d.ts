import { Agile, Observer } from '@agile-ts/core';
import { EventObserver, EventJob } from './internal';
export declare class Event<PayloadType = DefaultEventPayload> {
    agileInstance: () => Agile;
    config: EventConfigInterface;
    private initialConfig;
    _key?: EventKey;
    uses: number;
    callbacks: {
        [key: string]: EventCallbackFunction<PayloadType>;
    };
    enabled: boolean;
    observer: EventObserver;
    currentTimeout: any;
    queue: Array<EventJob>;
    payload: PayloadType;
    /**
     * @public
     * Event -  Class that holds a List of Functions which can be triggered at the same time
     * @param agileInstance - An instance of Agile
     * @param config - Config
     */
    constructor(agileInstance: Agile, config?: CreateEventConfigInterface);
    /**
     * @public
     * Set Key/Name of Event
     */
    set key(value: EventKey | undefined);
    /**
     * @public
     * Get Key/Name of Event
     */
    get key(): EventKey | undefined;
    /**
     * @internal
     * Set Key/Name of Event
     * @param value - New Key/Name of Event
     */
    setKey(value: EventKey | undefined): this;
    /**
     * @public
     * Registers new Callback Function that will be called if this Event gets triggered
     * @param callback - Callback Function that gets called if the Event gets triggered
     * * @return Key of Event
     */
    on(callback: EventCallbackFunction<PayloadType>): string;
    /**
     * @public
     * Registers new Callback Function that will be called if this Event gets triggered
     * @param key - Key of Callback Function
     * @param callback - Callback Function that gets called if the Event gets triggered
     */
    on(key: string, callback: EventCallbackFunction<PayloadType>): this;
    /**
     * @public
     * Triggers Events
     * @param payload - Payload that gets passed into the Callback Functions
     * @param keys - Keys of Callback Functions that get triggered (Note: if not passed all registered Events will be triggered)
     */
    trigger(payload: PayloadType, keys?: string[]): this;
    /**
     * @public
     * Disables Event
     */
    disable(): this;
    /**
     * @public
     * Enables Event
     */
    enable(): this;
    /**
     * @public
     * Resets Event
     */
    reset(): this;
    /**
     * @public
     * Removes Callback Function at given Key
     * @param key - Key of Callback Function that gets removed
     */
    removeCallback(key: string): this;
    /**
     * @internal
     * Triggers normal Event
     * @param payload - Payload that gets passed into the Callback Functions
     * @param keys - Keys of Callback Functions that get triggered (Note: if not passed all registered Events will be triggered)
     */
    normalTrigger(payload: PayloadType, keys?: string[]): void;
    /**
     * @internal
     * Triggers async Event (Events with a delay)
     * @param payload - Payload that gets passed into the Callback Functions
     * @param delay - Delay until Events get triggered
     * @param keys - Keys of Callback Functions that get triggered (Note: if not passed all registered Events will be triggered)
     */
    delayedTrigger(payload: PayloadType, delay: number, keys?: string[]): void;
}
export declare type EventKey = string | number;
export declare type DefaultEventPayload = {
    [key: string]: any;
};
export declare type EventCallbackFunction<PayloadType = DefaultEventPayload> = (payload: PayloadType) => void;
/**
 * @param key - Key/Name of Event
 * @param enabled - If Event can be triggered
 * @param maxUses - How often the Event can be used/triggered
 * @param delay - Delayed call of Event Callback Functions in milliseconds
 * @param overlap - If Events can overlap
 * @param rerender - If triggering an Event should cause a rerender
 * @param deps - Initial Dependents of Event
 */
export interface CreateEventConfigInterface {
    key?: EventKey;
    enabled?: boolean;
    maxUses?: number;
    delay?: number;
    overlap?: boolean;
    rerender?: boolean;
    dependents?: Array<Observer>;
}
/**
 * @param maxUses - How often the Event can be used/triggered
 * @param delay - Delayed call of Event Callback Functions in seconds
 * @param overlap - If Events can overlap
 * @param rerender - If triggering an Event should cause a rerender
 */
export interface EventConfigInterface {
    maxUses?: number;
    delay?: number;
    overlap?: boolean;
    rerender: boolean;
}
