"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeProperties = exports.clone = exports.createArrayFromObject = exports.generateId = exports.notEqual = exports.equal = exports.flatMerge = exports.defineConfig = exports.isJsonString = exports.isAsyncFunction = exports.isFunction = exports.normalizeArray = exports.includesArray = exports.isValidObject = exports.copy = void 0;
function copy(value) {
    if (!value)
        return value;
    const valConstructorName = Object.getPrototypeOf(value).constructor.name;
    if (!['object', 'array'].includes(valConstructorName.toLowerCase()))
        return value;
    let temp;
    const newObject = Array.isArray(value) ? [] : {};
    for (const property in value) {
        temp = value[property];
        newObject[property] = typeof temp === 'object' ? copy(temp) : temp;
    }
    return newObject;
}
exports.copy = copy;
function isValidObject(value, considerArray = false) {
    function isHTMLElement(obj) {
        try {
            return obj instanceof HTMLElement;
        }
        catch (e) {
            return (typeof obj === 'object' &&
                obj.nodeType === 1 &&
                typeof obj.style === 'object' &&
                typeof obj.ownerDocument === 'object');
        }
    }
    return (value !== null &&
        typeof value === 'object' &&
        !isHTMLElement(value) &&
        (considerArray ? true : !Array.isArray(value)));
}
exports.isValidObject = isValidObject;
function includesArray(array1, array2) {
    return array2.every((element) => array1.includes(element));
}
exports.includesArray = includesArray;
function normalizeArray(items, config = {}) {
    config = defineConfig(config, {
        createUndefinedArray: false,
    });
    if (!items && !config.createUndefinedArray)
        return [];
    return Array.isArray(items) ? items : [items];
}
exports.normalizeArray = normalizeArray;
function isFunction(value) {
    return typeof value === 'function';
}
exports.isFunction = isFunction;
function isAsyncFunction(value) {
    const valueString = value.toString();
    return (isFunction(value) &&
        (value.constructor.name === 'AsyncFunction' ||
            valueString.includes('__awaiter')));
}
exports.isAsyncFunction = isAsyncFunction;
function isJsonString(value) {
    if (typeof value !== 'string')
        return false;
    try {
        JSON.parse(value);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.isJsonString = isJsonString;
function defineConfig(config, defaults, overwriteUndefinedProperties) {
    if (overwriteUndefinedProperties === undefined)
        overwriteUndefinedProperties = true;
    if (overwriteUndefinedProperties) {
        const finalConfig = Object.assign(Object.assign({}, defaults), config);
        for (const key in finalConfig)
            if (finalConfig[key] === undefined)
                finalConfig[key] = defaults[key];
        return finalConfig;
    }
    return Object.assign(Object.assign({}, defaults), config);
}
exports.defineConfig = defineConfig;
function flatMerge(source, changes, config = {}) {
    config = defineConfig(config, {
        addNewProperties: true,
    });
    const _source = copy(source);
    if (!_source)
        return _source;
    const keys = Object.keys(changes);
    keys.forEach((property) => {
        if (!config.addNewProperties && !_source[property])
            return;
        _source[property] = changes[property];
    });
    return _source;
}
exports.flatMerge = flatMerge;
function equal(value1, value2) {
    return value1 === value2 || JSON.stringify(value1) === JSON.stringify(value2);
}
exports.equal = equal;
function notEqual(value1, value2) {
    return !equal(value1, value2);
}
exports.notEqual = notEqual;
function generateId(length) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    let result = '';
    if (!length)
        length = 5;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}
exports.generateId = generateId;
function createArrayFromObject(object) {
    const array = [];
    for (const key in object) {
        array.push({
            key: key,
            instance: object[key],
        });
    }
    return array;
}
exports.createArrayFromObject = createArrayFromObject;
function clone(instance) {
    const objectCopy = Object.create(Object.getPrototypeOf(instance));
    const objectClone = Object.assign(objectCopy, instance);
    for (const key in objectClone)
        objectClone[key] = copy(objectClone[key]);
    return objectClone;
}
exports.clone = clone;
function removeProperties(object, properties) {
    const copiedObject = copy(object);
    properties.map((property) => delete copiedObject[property]);
    return copiedObject;
}
exports.removeProperties = removeProperties;
