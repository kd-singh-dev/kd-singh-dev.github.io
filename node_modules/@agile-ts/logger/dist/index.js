"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const utils_1 = require("@agile-ts/utils");
class Logger {
    constructor(config = {}) {
        this.allowedTags = [];
        this.loggerCategories = {};
        this.watchers = {};
        let _config = typeof config === 'function' ? config(this) : config;
        _config = utils_1.defineConfig(_config, {
            prefix: '',
            allowedTags: [],
            canUseCustomStyles: true,
            active: true,
            level: 0,
            timestamp: false,
        });
        this.isActive = _config.active;
        this.allowedTags = _config.allowedTags;
        this.config = {
            timestamp: _config.timestamp,
            prefix: _config.prefix,
            canUseCustomStyles: _config.canUseCustomStyles,
            level: _config.level,
        };
        this.addDefaultLoggerCategories();
    }
    get if() {
        return {
            tag: (tags) => this.tag(tags),
        };
    }
    static get level() {
        return {
            TRACE: 1,
            DEBUG: 2,
            LOG: 5,
            TABLE: 5,
            INFO: 10,
            SUCCESS: 15,
            WARN: 20,
            ERROR: 50,
        };
    }
    addDefaultLoggerCategories() {
        this.createLoggerCategory({
            key: 'log',
            level: Logger.level.LOG,
        });
        this.createLoggerCategory({
            key: 'debug',
            customStyle: 'color: #656565;',
            prefix: 'Debug',
            level: Logger.level.DEBUG,
        });
        this.createLoggerCategory({
            key: 'info',
            customStyle: 'color: #6c69a0;',
            prefix: 'Info',
            level: Logger.level.INFO,
        });
        this.createLoggerCategory({
            key: 'success',
            customStyle: 'color: #00b300;',
            prefix: 'Success',
            level: Logger.level.SUCCESS,
        });
        this.createLoggerCategory({
            key: 'warn',
            prefix: 'Warn',
            level: Logger.level.WARN,
        });
        this.createLoggerCategory({
            key: 'error',
            prefix: 'Error',
            level: Logger.level.ERROR,
        });
        this.createLoggerCategory({
            key: 'trace',
            prefix: 'Trace',
            level: Logger.level.TRACE,
        });
        this.createLoggerCategory({
            key: 'table',
            level: Logger.level.TABLE,
        });
    }
    tag(tags) {
        if (utils_1.includesArray(this.allowedTags, tags)) {
            return {
                log: (...data) => this.log(...data),
                debug: (...data) => this.debug(...data),
                info: (...data) => this.info(...data),
                success: (...data) => this.success(...data),
                warn: (...data) => this.warn(...data),
                error: (...data) => this.error(...data),
                trace: (...data) => this.trace(...data),
                table: (...data) => this.table(...data),
            };
        }
        return {
            log: () => {
            },
            debug: () => {
            },
            info: () => {
            },
            success: () => {
            },
            warn: () => {
            },
            error: () => {
            },
            trace: () => {
            },
            table: () => {
            },
        };
    }
    log(...data) {
        this.invokeConsole(data, 'log', 'log');
    }
    debug(...data) {
        this.invokeConsole(data, 'debug', typeof console.debug !== 'undefined' ? 'debug' : 'log');
    }
    info(...data) {
        this.invokeConsole(data, 'info', typeof console.info !== 'undefined' ? 'info' : 'log');
    }
    success(...data) {
        this.invokeConsole(data, 'success', 'log');
    }
    warn(...data) {
        this.invokeConsole(data, 'warn', typeof console.warn !== 'undefined' ? 'warn' : 'log');
    }
    error(...data) {
        this.invokeConsole(data, 'error', typeof console.error !== 'undefined' ? 'error' : 'log');
    }
    trace(...data) {
        this.invokeConsole(data, 'trace', typeof console.trace !== 'undefined' ? 'trace' : 'log');
    }
    table(...data) {
        this.invokeConsole(data, 'table', typeof console.table !== 'undefined' ? 'table' : 'log');
    }
    custom(loggerCategory, ...data) {
        this.invokeConsole(data, loggerCategory, 'log');
    }
    invokeConsole(data, loggerCategoryKey, consoleLogType) {
        const loggerCategory = this.getLoggerCategory(loggerCategoryKey);
        if (!this.isActive || loggerCategory.level < this.config.level)
            return;
        const buildPrefix = () => {
            let prefix = '';
            if (this.config.timestamp)
                prefix = prefix.concat(`[${Date.now().toString()}] `);
            if (this.config.prefix)
                prefix = prefix.concat(this.config.prefix);
            if (loggerCategory.prefix)
                prefix = prefix.concat(' ' + loggerCategory.prefix);
            if (this.config.prefix || loggerCategory.prefix)
                prefix = prefix.concat(':');
            return prefix;
        };
        if (typeof data[0] === 'string')
            data[0] = buildPrefix().concat(' ').concat(data[0]);
        else
            data.unshift(buildPrefix());
        for (const key in this.watchers) {
            const watcher = this.watchers[key];
            if (loggerCategory.level >= (watcher.level || 0)) {
                watcher.callback(loggerCategory, data);
            }
        }
        if (this.config.canUseCustomStyles && loggerCategory.customStyle) {
            const newLogs = [];
            let hasStyledString = false;
            for (const log of data) {
                if (!hasStyledString && typeof log === 'string') {
                    newLogs.push(`%c${log}`);
                    newLogs.push(loggerCategory.customStyle);
                    hasStyledString = true;
                }
                else {
                    newLogs.push(log);
                }
            }
            data = newLogs;
        }
        if (consoleLogType === 'table') {
            if (typeof data[0] === 'string') {
                console.log(data[0]);
                console.table(data.filter((d) => typeof d !== 'string' && 'number'));
            }
            return;
        }
        console[consoleLogType](...data);
    }
    createLoggerCategory(loggerCategory) {
        loggerCategory = utils_1.defineConfig(loggerCategory, {
            prefix: '',
            level: 0,
        });
        this.loggerCategories[loggerCategory.key] = loggerCategory;
    }
    getLoggerCategory(key) {
        return this.loggerCategories[key];
    }
    watch(keyOrConfig, config) {
        const generateKey = utils_1.isValidObject(keyOrConfig);
        let _config;
        let key;
        if (generateKey) {
            key = utils_1.generateId();
            _config = keyOrConfig;
        }
        else {
            key = keyOrConfig;
            _config = config;
        }
        _config = utils_1.defineConfig(_config, {
            level: 0,
        });
        if (!utils_1.isFunction(_config.callback)) {
            console.error('Agile: A Watcher Callback Function has to be an function!');
            return this;
        }
        if (this.watchers[key]) {
            console.error(`Agile: Watcher Callback Function with the key/name ${key} already exists!`);
            return this;
        }
        this.watchers[key] = _config;
        return generateKey ? key : this;
    }
    removeWatcher(key) {
        delete this.watchers[key];
        return this;
    }
    setLevel(level) {
        this.config.level = level;
        return this;
    }
}
exports.Logger = Logger;
